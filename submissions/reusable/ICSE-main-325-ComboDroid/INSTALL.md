

Source code repository: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3666313.svg)](https://doi.org/10.5281/zenodo.3666313)  

Virtual machine repository: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3673079.svg)](https://doi.org/10.5281/zenodo.3673079)  

# Install ComboDroid  
  
## TL;DR (Linux or Windows, Using Pre-build VM Image)

Download the [VirtualBox VM Image](https://doi.org/10.5281/zenodo.3673079) and import it (click "File -> Import Appliance" menu item and select the `ova` file; the import process may take a few minutes).
Test subjects are also shipped with the VM image for reproducing experimental results.

**Important Notes**:

* It is mandatory to use VirtualBox >= 6.1.2 with nested virtualization.
* On Windows hosts (even with latest VirtualBox), the performance would slightly hurt. The artifact still works.
* The VM image consumes lots of disk space (~30 GiB).
* If you see a `BrokenSharedFolder` warning at VM booting, just ignore it.

## Build from Source Code (Linux)

The source code is available at [this link](https://doi.org/10.5281/zenodo.3666313).

**Dependencies**: JDK-1.8 and Android SDK. If you have Android Studio installed, all dependencies are just set.

### Source Code Repository Overview

- The `Client` directory containing source code for the client of ComboDroid deployed on the Android device to generate and send events;  
- The `Controller` directory containing source code for the controller of ComboDroid running on the computer to control the client;  
- The build.sh file that can be used to compile and build the artifact; and  
- The README.md file containing instructions to build the tool (all contents are also included in this section).  

### Build Guide

Before build, make sure that the path to the d8 compiler of the Android SDK exists in the `PATH` environment variable, which is normally at `[SDK_LOCATION]/build-tools/29.0.3`. Try `d8` in bash to test if `PATH` is set correctly.

To build the artifact, we need to build two jar files, namely a controller jar named `ComboDroid.jar` and a client jar named `client.jar`.
We provide a build script `build.sh` to build these two jars. 
We first introduce how to build with `build.sh` and then how to build without it.

#### TL;DR (Build with `build.sh`)

To build, at `ComboDroid` directory do:  

```bash  
./build.sh  
```

A correct build generates `client.jar` and `ComboDroid.jar` at the source code directory  `ComboDroid`. 

We next describe how to build the artifact without `build.sh`.

#### Build controller  

To build the controller, run:  
```bash  
cd Controller  
./gradlew jar
cp build/libs/ComboDroid-1.0-SNAPSHOT.jar ../ComboDroid.jar
```  
at the source code directory  `ComboDroid`.  
The jar file will be generated by Gradle.  
The jar file will be at `ComboDroid/ComboDroid.jar`.  
  

#### Build client  
  

To build the client, run:  
```bash  
cd Client  
./gradlew jar  
d8 build/libs/client-1.0-SNAPSHOT.jar --output ../client.jar  
```  
at the source code directory  `ComboDroid`.  
The jar file will be first generated by Gradle,  
and then processed by the d8 compiler to generate the final jar file with dex files inside.  
The `--output` option of the command is used to specify the location and name of the final jar.  
The above command will generate the `client.jar` file at the source code directory  `ComboDroid`.

#### Usage of the built artifact

The built artifact, namely two jar files, can be used within our virtual machine environment.
Copy the two jar files to the `/home/combodroid/artifact` directory of the virtual machine,
replace the `ComboDroid.jar` with the controller jar file and `client.jar` with the client jar file, respectively, 
and run it using the scripts introduced in  `Readme.md`.

To use it outside the virtual machine, do the followings:
1. Connect an Android device of API 23 via adb;
2. Prepare the configuration file mentioned in `Readme.md`;
3. Run 
    ```bash
    java -jar ComboDroid.jar PATH_TO_CONFIGURATION_FILE
    ```
    at the directory of the artifact.
     
The execution log will be directly printed on the shell.

